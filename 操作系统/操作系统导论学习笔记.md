# 操作系统导论学习笔记

##  第二章 操作系统介绍

### 2.2 虚拟化内存

### 2.3 并发

### 2.4 持久性

![如何持久地存储数据](image.png)

操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS有时被视为标准库。

操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源（resources），甚对它们进行虚拟化（virtualize）。它处理与甚发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。
### 2.5 设计目标

设计和实现操作系统的目标:
1. 提供高性能；
2. 在OS和应用程序之间提供保护。

### 2.6 简单历史

系统调用：添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为更正式的、受控的过程。

UNIX系统的重要性举足轻重。——计算之神

## 第三章 关于虚拟化的对话

## 第四章 抽象：进程

### 4.1 抽象：进程

进程：运行中的程序

![如何提供有多个CPU的假象？](image.png)

OS通过虚拟化（virtualizing）CPU来提供这种假象，通过让一个进程只运行一个时间片，然后切换到其他进程，OS提供了存在多个虚拟CPU的假象，这就是时分共享（time sharing）CPU技术，允许用户如愿运行多个并发进程。

实现CPU的虚拟化，要实现的好，OS就需要一些低级机制以及一些高级智能。低级机制成为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。

上下文切换（context switch）：让操作系统能够停止运行一个程序，并开始在给定的CPU上运行另一个程序，所有现代OS都采用这种分时机制。

在机制之上，有一些智能以策略（policy）的形式存在。策略是在操作系统内做出某种决定的算法。

机器状态（machine stata）：程序在运行时可以读取或更新的内容。在任何时刻，机器的那部分对执行该程序很重要？

内存，进程可以访问的内存（成为地址空间，address space）是该进程的一部分。另一部分是寄存器，许多指令明确地读取或更新寄存器。

### 4.2 进程API

* 创建（create）-双击程序图标，或者shell键入命令
* 销毁（destroy）-强制销毁进程的接口
* 等待（wait）
* 其他控制（miscellaneous control）
* 状态（statu） 

### 4.3 进程创建：更多细节

程序如何转化为进程。

静态数据——>内存（load）

早期操作系统中，加载过程应该尽早完成，即在运行程序之前完成。现代操作系统（lazily）执行该过程。必须为程序的运行时栈（run-time stack或stack）分配一些内存。C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与I/O设置相关的其他工作，OS现在为程序执行搭好了舞台。最后一项任务，启动程序，在入口处运行。通过跳转到main()例程，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行。

### 4.4 进程状态

* **运行（running）** 运行状态下，进程在处理器上运行。
* **就绪（ready）**   
* **堵塞（block）** 在堵塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。

### 4.5 数据结构

数据结构是一个程序，可以跟踪各种相关的信息。

操作系统追踪进程的一些重要信息。对于停止的进程，寄存器上下文将保存其寄存器的内容。

僵尸状态：进程处于已退出但是未清理的状态，它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行。完成后，父进程将进行最后一次调用（例如，wait（）），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程所有相关的数据结构。

进程：一个正在运行的程序。实现进程所需的低级机制和以智能方式调度这些进程所需的高级策略。

## 第五章 插叙：进程API

UNIX 系统中的进程创建。

UNIX系统采用非常有趣的创建新进程的方式，即通过一对系统调用：fork() 和 exec() 。
进程还可以通过第三个系统调用 wait(),来等待其创建的子进程执行完成。

### 5.1 fork()系统调用

进程调用了fork()系统调用，这是操作系统提供的创建新进程的方法。
CPU调度程序（scheduler）决定了某个时刻哪个进程被执行，由于CPU调度程序非常复杂，所以我们不能假设哪个进程会先执行。这种不确定性（non-determinism）会导致一些很有趣的问题，特别在多线程程序中。

### 5.2 wait()系统调用

调用wait()，延迟自己的执行。

### 5.3 最后是exec()系统调用

最后是exec()系统调用，它也是创建进程API的一个重要部分。这个系统调用可以让子进程执行与父进程不同的程序。

exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆，栈及其他内存空间也会被重新初始化，然后操作系统就执行该程序，将参数通过argv传递给该程序。因此，它没有创建新进程，而是选择替换。

### 5.4 为什么这样设计API

重要的是做对事（Get it right）——《Hints for Computer System Design》

UNIX管道用类似的方式实现，用的是pipe()系统调用。

一个进程的输出 ——> 一个内核管道（pipe）上（队列）——> 一个进程的输入

**RTFM——阅读man手册 (哈哈)**

### 5.5 其他API

kill()

## 第六章 机制：受限直接执行

未来虚拟化CPU，操作系统需要以某种方式让许多任务共享物理CPU，让它们看起来像是同时运行。
基本思想很简单：运行一个进程一段时间，然后运行另一个进程，如此轮换。通过以这种方式分时共享CPU，就实现了虚拟化。

构建这样的虚拟化机制存在一些挑战：
- 第一个是性能：如何在不增加系统开销的情况下实现虚拟化？
- 第二个是控制权：如何有效运行进程，同时保留对CPU的控制？控制权对操作系统尤为重要，因为操作系统负责资源管理。

## 6.1 基本技巧：受限直接执行

OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。

操作系统对运行程序有所限制！

## 6.2 问题1：受限制的操作

硬件通过提供不同的执行模式来协助操作系统，在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式下（kernel model）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。

对于I/O和其他相关操作，一种方法就是让进程做所有它想做的事情。但是，这样做导致无法构建许多我们想要的系统。

与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出I/O请求和执行所有类型的受限指令。 

如果用户希望执行某种特权操作（如从磁盘读取），为实现这一点，几乎所有的现代硬件都提供了用户程序执行系统调用的能力。它允许内核小心地向用户程序暴露某些关键功能。

执行陷阱，硬件必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回。

当你调用opne()时，你正在执行对C库的过程调用。其中，无论是对open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放在众所周知的位置。

因此，C库中进行系统调用的部分是用汇编手工编码的，因此他们需要仔细与欸的那个，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。

内核通过在启动时设置陷阱表来实现。机器启动时，它在特权模式下执行，因此可以根据需要自由配置机器硬件。

## 6.3 问题2：在进程之间切换

直接执行的下一个问题时实现进程之间的切换。

问题在于：如何重新获得CPU的控制权。

