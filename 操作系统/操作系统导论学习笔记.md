# 操作系统导论学习笔记
##  第二章 操作系统介绍

### 2.2 虚拟化内存

### 2.3 并发

### 2.4 持久性

![如何持久地存储数据](image.png)

操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS有时被视为标准库。

操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源（resources），甚对它们进行虚拟化（virtualize）。它处理与甚发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。
### 2.5 设计目标

设计和实现操作系统的目标:
1. 提供高性能；
2. 在OS和应用程序之间提供保护。

### 2.6 简单历史

系统调用：添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为更正式的、受控的过程。

UNIX系统的重要性举足轻重。——计算之神

## 第三章 关于虚拟化的对话

## 第四章 抽象：进程

### 4.1 抽象：进程

进程：运行中的程序

![如何提供有多个CPU的假象？](image.png)

OS通过虚拟化（virtualizing）CPU来提供这种假象，通过让一个进程只运行一个时间片，然后切换到其他进程，OS提供了存在多个虚拟CPU的假象，这就是时分共享（time sharing）CPU技术，允许用户如愿运行多个并发进程。

实现CPU的虚拟化，要实现的好，OS就需要一些低级机制以及一些高级智能。低级机制成为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。

上下文切换（context switch）：让操作系统能够停止运行一个程序，并开始在给定的CPU上运行另一个程序，所有现代OS都采用这种分时机制。

在机制之上，有一些智能以策略（policy）的形式存在。策略是在操作系统内做出某种决定的算法。

机器状态（machine stata）：程序在运行时可以读取或更新的内容。在任何时刻，机器的那部分对执行该程序很重要？

内存，进程可以访问的内存（成为地址空间，address space）是该进程的一部分。另一部分是寄存器，许多指令明确地读取或更新寄存器。

### 4.2 进程API

* 创建（create）-双击程序图标，或者shell键入命令
* 销毁（destroy）-强制销毁进程的接口
* 等待（wait）
* 其他控制（miscellaneous control）
* 状态（statu） 

### 4.3 进程创建：更多细节

程序如何转化为进程。

静态数据——>内存（load）

早期操作系统中，加载过程应该尽早完成，即在运行程序之前完成。现代操作系统（lazily）执行该过程。必须为程序的运行时栈（run-time stack或stack）分配一些内存。C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与I/O设置相关的其他工作，OS现在为程序执行搭好了舞台。最后一项任务，启动程序，在入口处运行。通过跳转到main()例程，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行。

### 4.4 进程状态

* **运行（running）** 运行状态下，进程在处理器上运行。
* **就绪（ready）**   
* **堵塞（block）** 在堵塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。

### 4.5 数据结构

数据结构是一个程序，可以跟踪各种相关的信息。

操作系统追踪进程的一些重要信息。对于停止的进程，寄存器上下文将保存其寄存器的内容。

僵尸状态：进程处于已退出但是未清理的状态，它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行。完成后，父进程将进行最后一次调用（例如，wait（）），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程所有相关的数据结构。

进程：一个正在运行的程序。实现进程所需的低级机制和以智能方式调度这些进程所需的高级策略。

## 第五章 插叙：进程API

UNIX 系统中的进程创建。

UNIX系统采用非常有趣的创建新进程的方式，即通过一对系统调用：fork() 和 exec() 。
进程还可以通过第三个系统调用 wait(),来等待其创建的子进程执行完成。

### 5.1 fork()系统调用

进程调用了fork()系统调用，这是操作系统提供的创建新进程的方法。
CPU调度程序（scheduler）决定了某个时刻哪个进程被执行，由于CPU调度程序非常复杂，所以我们不能假设哪个进程会先执行。这种不确定性（non-determinism）会导致一些很有趣的问题，特别在多线程程序中。

### 5.2 wait()系统调用

调用wait()，延迟自己的执行。

### 5.3 最后是exec()系统调用

最后是exec()系统调用，它也是创建进程API的一个重要部分。这个系统调用可以让子进程执行与父进程不同的程序。

exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆，栈及其他内存空间也会被重新初始化，然后操作系统就执行该程序，将参数通过argv传递给该程序。因此，它没有创建新进程，而是选择替换。

### 5.4 为什么这样设计API

重要的是做对事（Get it right）——《Hints for Computer System Design》

UNIX管道用类似的方式实现，用的是pipe()系统调用。

一个进程的输出 ——> 一个内核管道（pipe）上（队列）——> 一个进程的输入

**RTFM——阅读man手册 (哈哈)**

### 5.5 其他API

kill()

## 第六章 机制：受限直接执行

未来虚拟化CPU，操作系统需要以某种方式让许多任务共享物理CPU，让它们看起来像是同时运行。
基本思想很简单：运行一个进程一段时间，然后运行另一个进程，如此轮换。通过以这种方式分时共享CPU，就实现了虚拟化。

构建这样的虚拟化机制存在一些挑战：
- 第一个是性能：如何在不增加系统开销的情况下实现虚拟化？
- 第二个是控制权：如何有效运行进程，同时保留对CPU的控制？控制权对操作系统尤为重要，因为操作系统负责资源管理。

## 6.1 基本技巧：受限直接执行

