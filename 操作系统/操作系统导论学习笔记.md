# 操作系统导论学习笔记
##  第二章 操作系统介绍

### 2.2 虚拟化内存

### 2.3 并发

### 2.4 持久性

![如何持久地存储数据](image.png)

操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS有时被视为标准库。

操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源（resources），甚对它们进行虚拟化（virtualize）。它处理与甚发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。
### 2.5 设计目标

设计和实现操作系统的目标:
1. 提供高性能；
2. 在OS和应用程序之间提供保护。

### 2.6 简单历史

系统调用：添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为更正式的、受控的过程。

UNIX系统的重要性举足轻重。——计算之神

## 第三章 关于虚拟化的对话

## 第四章 抽象：进程

### 4.1 抽象：进程

进程：运行中的程序

![如何提供有多个CPU的假象？](image.png)

OS通过虚拟化（virtualizing）CPU来提供这种假象，通过让一个进程只运行一个时间片，然后切换到其他进程，OS提供了存在多个虚拟CPU的假象，这就是时分共享（time sharing）CPU技术，允许用户如愿运行多个并发进程。

实现CPU的虚拟化，要实现的好，OS就需要一些低级机制以及一些高级智能。低级机制成为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。

上下文切换（context switch）：让操作系统能够停止运行一个程序，并开始在给定的CPU上运行另一个程序，所有现代OS都采用这种分时机制。

在机制之上，有一些智能以策略（policy）的形式存在。策略是在操作系统内做出某种决定的算法。

机器状态（machine stata）：程序在运行时可以读取或更新的内容。在任何时刻，机器的那部分对执行该程序很重要？

内存，进程可以访问的内存（成为地址空间，address space）是该进程的一部分。另一部分是寄存器，许多指令明确地读取或更新寄存器。

### 4.2 进程API

* 创建（create）-双击程序图标，或者shell键入命令
* 销毁（destroy）-强制销毁进程的接口
* 等待（wait）
* 其他控制（miscellaneous control）
* 状态（statu） 

### 4.3 进程创建：更多细节

程序如何转化为进程。

静态数据——>内存（load）

早期操作系统中，加载过程应该尽早完成，即在运行程序之前完成。现代操作系统（lazily）执行该过程。必须为程序的运行时栈（run-time stack或stack）分配一些内存。C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与I/O设置相关的其他工作，OS现在为程序执行搭好了舞台。最后一项任务，启动程序，在入口处运行。通过跳转到main()例程，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行。

### 4.4 进程状态

* **运行（running）** 运行状态下，进程在处理器上运行。
* **就绪（ready）**   
* **堵塞（block）** 在堵塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。

### 4.5 数据结构

数据结构是一个程序，可以跟踪各种相关的信息。