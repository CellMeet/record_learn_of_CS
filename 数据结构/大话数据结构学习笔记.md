# 大话数据结构学习笔记

## 第二章 算法

### 2.9 算法时间复杂度

对数阶：
O（logn）

### 2.11 最坏情况与平均情况

### 2.12 算法空间复杂度

## 第三章 线性表

### 3.6 线性表的链式存储结构

链式结构中，存储数据信息和后继元素的存储地址。
为了表示每个数据元素$a_{i}$与其直接后继元素$a_{i+1}$直接的逻辑关系。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域成为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素$a_i$的存储映像，称为结点（Node）。

对于线性表，需要头尾，链表也不例外。我们把链表第一个结点的存储位置叫做头指针，那么整个链表的存取就是从头指针开始进行了。之后的每一个结点，其实就是上一个后继指针指向的位置。

### 3.12 静态链表

首先让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，存放数据元素，也就是通常我们要处理的数据，游标cur，存放元素后继在数组的下标。

为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，可以从链表上去的第一个结点作为待插入的新结点。

# 3.13 循环链表

采用尾指针合并循环链表

```C
p=rearA->next;
rearA->next =rearB->next->next;
rearB->next=p;
free(p);
```
# 3.14 双向链表

双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域，所以双向链表中有两个指针域，一个指向直接后继，另一个指向前驱。

```C
p->next->prior = p = p->prior->next
```

双向链表插入和删除时，需要更改两个指针变量。

```C
//插入操作
s->prior = p;
s->next = p->next;
p->next->prior = s;
p->next = s;
```



## 第四章 栈与队列

栈与队列：
栈是限定仅在表尾进行插入和删除操作的线性表
队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。

栈的抽象数据结构
```C
ADT 栈（stack）
Data 
 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。

Operation
      InitStack（*S）： 初始化操作，建立一个空栈S。
      DestroyStack（*S）：若栈存在，则销毁它。
      ClearStack（*S）：将栈清空。

      StackEmpty（S）：若栈为空，则返回true，否则返回false。
      GetTop（S，*e）：若栈为非空，用e返回S的栈顶元素。
      Push（*S，e）：若栈S存在，插入新元素e到栈S中并成为栈顶元素。
      Pop（*S，*e）：删除栈S中栈顶元素，并用e返回其值。
      StackLength（S）：返回栈S的元素个数。
endADT
```

进栈操作
```C
/*插入元素e为新的栈顶元素*/
Status Push(SqStack *S，SElemType e)
{
    if(S->top == MAXSIZE -1)
    {
        return ERROR;
    }
    S->TOP++;
    S->data[S->top]=e;
    return OK;
}
```

### 4.5 两栈共享空间

```C
/* 两栈共享空间结构 */
typedef struct
{
    SElmtype data[MAXSIZE];
    int top1; /* 栈1 栈顶指针*/
    int top2；/* 栈2 栈顶指针*/
}SqDoubleStack；
```

通常是一个栈增长，另一个栈缩短的情况，就像买卖股票一样。
这只是针对具有相同数据类型的栈的设计上的技巧。

### 4.6 栈的链式存储结构及实现

```C
Status Push(LinkStack *S,SElmeType e)
{
    LinkStackPtr s = (LinkStackPtr) malloc (sizeof(StackNode));
    s->data = e;
    s->next = S->top;
    S->top =s;
    S->count++;
    return OK;
}
```

### 4.8 栈的应用——递归

栈有一个很重要的应用：在程序设计语言中实现了递归。

递归实现了函数对自己的调用。我们把一个直接调用自己或通过一系列的调用语句间接调用自己的函数，称作递归函数。

递归过程退回的顺序是它前行顺序的逆序，在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。

### 4.9 栈的应用——四则运算表达式求值

栈用来处理括号，碰到左括号，就进栈，遇到右括号，让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空到有元素，最终再因匹配成功变成空栈。

**逆波兰表示法**：？？？是人能想出来的？

### 4.10 队列的定义

队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出（FIFO）的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。

### 4.12 循环队列

线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。

front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。

为了避免"假溢出"，因为数组末尾元素已经占用，再向后加，会产生数组越界错误。但是队列在下标为0和1的地方还是空闲的。

办法一是设置一个标志变量flag，当rear == front时，且flag = 0时队列为空，当flag = 1时为队列满。

办法二是当队列空时，条件就是front = rear，队列满时，修改条件，就是空一个元素当作队列满。 此时 （rear+1）%QueneSize == front，所以此时队列满。

通用的队列长度计算公式为：

**（rear-front+QueueSize）%QueueSize**

### 4.13 队列的链式存储结构及实现

队列的链式存储结构，其实就是线性表的单链表。

## 第五章 串

串：串是由零个或多个字符组成的有限序列，又名叫字符串。

常用字符是使用标准的ASCII编码，->Unicode编码


### 5.4 串的抽象数据类型

操作Index的实现算法，
```C
/* T为非空串，若主串S中第pos个字符之后存在与T相等的字串，*/
/* 则返回第一个这样的字串在S中的位置，否则返回0 */

int Index（String S，String T，int pos）
{
    int n,m,i;
    String sub;
    if(pos > 0){
        n = StrLength(S);
        m = StrLength(T);
        i = pos;
        while(i <= n-m+1)
        {
            SubString(sub,S,i,m);
            if(StrCompare(sub,T)!=0)
            ++i;
            else
            return i;
        }
    }
    return 0;
}
```

串的存储结构与线性表相同，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做"堆"。

### 5.6 朴素的模式匹配算法

### 5.7 KMP模式匹配算法

加粗的为相对于朴素

## 第六章 树

### 6.2 树的定义

子树不相交。

树的结点包含一个数据元素及若干指向其子树的分支，结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。

结点间的关系

结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent），同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，D,B,A都是它的祖先。反之，以某根节点为根的子树中的任一几点都称为该结点的子孙。B的子孙有D,G,H,I。

### 6.4 树的存储结构

**双亲表示法：**
每个结点中，附设一个指示器指示其双亲结点到链表中的位置，也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。它的结构链表下表所示：
其中data是数据域，存储结点的数据信息，而parent是指针域，存储该结点的双亲在数组中的下标。

以下是我们的双亲表示法的结点结构定义代码。
```C
/* 树的双亲表示法结点结构定义*/
#define MAX_TREE_SIZE100
typedef int TElemType； /* 树结点的数据类型，目前暂定为整形 */
typedef struct PTNode /* 结点结构 */
{
    TElemType data;
    int parent;
} PTNode;

typedef struct  /* 树结构 */
{
PTNode nodes{MAX_TREE_SIZE};
int r，n；
} PTree；
```

我们增加一个结点最左边孩子的域，叫做长子域。

**孩子表示法：**

由于树中每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的，所以可以设计两种方案来解决。

方案一：
一种是指针域的个数就等于树的度，复习一下，树的度是树各个结点度的最大值。

方案二：
第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数。

我们再对每个结点的孩子建立一个单链表体现它们的关系。

把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成了一个线性表，采用顺序存储结构，存放进一个一维数组中，如图所示。

为此，设计两种结点结构，一个是孩子链表的孩子结点。

双亲孩子表示法

**孩子兄弟表示法：**

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。

这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过fistchild找到此结点的长子，然后通过rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。

### 6.5 二叉树的定义

二叉树（Binary Tree）是n（n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

### 6.6 二叉树的性质

二叉树性质5

### 6.7 二叉树的存储结构

### 6.8 遍历二叉树

**1、前序遍历**
先访问根结点，然后前序遍历左子树，再前序遍历右子树，如图6-8-2所示，遍历的顺序为：
ABDGHCEIF。

**2、中序遍历**
规则是若树为空，则空操作返回，否则从根结点开始，中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。左->中->右

**3、后序遍历**
规则是若树为空，则空操作返回，否则从左到右叶子后结点的方式遍历访问左右子树，最后是访问根结点。左->右->中

**4、层序遍历**
简单易懂

```C
/* 二叉树的前序遍历递归算法*/
void PreOrderTraverse（BiTree T）
{
    if（T == NULL）
    return；
    printf（"%c",T->data);
    PreOrderTraverse(T->lchilid);
    PreOrderTraverse(T->rchilid);
}
```

```C
/* 二叉树的中序遍历算法*/
void InOrderTraverse(BiTree T)
{
    if(T == NULL)
    return;
    InOrderTraverse(T->lchild);
    printf("%c",T->data);
    InOrderTraverse(T->rchild);
}
```

```C
/* 二叉树的后序遍历算法*/
void PostOrderTraverse(BiTree T)
{
    if(T == NULL)
    return;
    PostOrderTraverse(T->lchild);
    PostOrderTraverse(T->rchild);
    printf("%c",T->data);
}
```

### 6.9 二叉树的建立

```C
/* 按前序输入二叉树中结点的值（一个字符）*/
void CreateBiTree(BiTree *T)
{
    TElemType ch;
    scanf("%c",&ch);
    if(ch == '#')
    *T = NULL;
    else
    {
        
    }
}








```


















